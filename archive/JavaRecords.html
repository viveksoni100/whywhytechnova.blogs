<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>Java Records</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/meyer-reset/2.0/reset.min.css">
<link rel="stylesheet" href="./style.css">

</head>
<body>
<main>
<div class="triangle"></div>
<div class="triangle-2"></div>
<div class="triangle-3"></div>
<div class="container">

  <article>
  <h1>How Java 14's data 'records' will change the way we code</h1>
  <div class="metadata">
    <span class="author">by Vivek Soni üòä </span>
    <span class="date">25 January 2020</span>
  </div>

  <p class="highlightme">Why record class is introduced?</p>
<p>
<ul>
Record is a new form of Java class designed to<br>
<li>‚ùØ Provide a first-class means for modeling data aggregation</li>
<li>‚ùØ Close a possible gap in Java's type system</li>
<li>‚ùØ Provide language-levle syntax for a common programming pattern</li>
<li>‚ùØ Reduce class boilerplate</li>
</ul>
</p>

<p class="highlightme">When will the record class will come into being?</p>
<p>
Java 14's record class is a new feature, which is under active development and is targeted to appear as a preview in Java 14 (which will be released in March).
</p>

<p class="highlightme">What is a Java record?</p>
<p>
If you ask a developer that what is a bad thing about Java? they will immediately say writing an excess amount of coding. Well which is true, we need to write a lot of code for a class to be useful. For instance, a Java bean class, in which we write
</p>
<p>
<ul>
<li>‚ùØ toString()</li>
<li>‚ùØ hasCode() and equals()</li>
<li>‚ùØ Getter and Setter methods</li>
<li>‚ùØ A public constructor</li>
</ul>
</p>

<p>
these methods are usually boring, repetitive, and the kind of thing that could easily be generated by IDEs, but as of now, the language itself doesn't provide any way to do this.
</p>

<p>
These methods are at their worst when we are reading someone else's code. For example, it might look like the author is using IDE-generated hasCode() and equals() that handle all the fields of the class, but how can we be sure without checking each line of the implementation? What happens if a field is added during refactoring and the methods are not regenerated?. For those who don't know about hasCode() method let me say it returns a hash code value for the object, for more understanding go to <br>https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html
</p>

<p class="highlightme">What is the goal of record?</p>
<p>
The goal of records is to extend the Java language syntax and enable the compiler to generate all the methods automatically and having all the fields participate in methods such as hashCode().
</p>
<br />
<p class="highlightme">The example without Records:</p>
<p>
In this example, I am going to use the Employee class as an example domain to explain records. I will show how we can use them to improve our modeling of the domain and get cleaner, less verbose, simpler code as a result.
</p>

<pre>
<code>
public final class Employee {

	//instance variables
	private final int empId;
	private final String empName;
	private final float empSalary;
	private final String empProject;
	private final LocalDateTime empJoiningDate;

	//constructor
	public Employee(int empId,
		String empName,
		float empSalary,
		String empProject,
		LocalDateTime empJoiningDate) {
	this.empId = empId;
	this.empName = empName;
	this.empSalary = empSalary;
	this.empProject = empProject;
	this empJoiningDate = empJoiningdate;
	}

	//getter-methods
	public int empId(){
		return empId;
	}

	public String empName(){
		return empName;
	}

	public float empSalary(){
		return empSalary;
	}

	public String empProject(){
		return empProject;
	}

	public LocalDateTime empJoiningDate(){
		return empJoiningDate;
	}

	//equals-method
	@Override
	public boolean equals(Object o){
		if(this == o) return true;
		if(o == null || getClass() != o.getClass())
			return false;
		Employee that = (Employee) o;

		if(empId != that.empId) return false;
		if(empName != that.empName) return false;
		if(Float.compare(that.empSalary, empSalary) != 0)
                    return false;
		if(empProject != that.empProject)
                    return false;
		if(!(empJoiningDate.equals(that.empJoiningDate)))
                    return false;
	}

	//hashCode-method
	@Override
	public int hashCode(){
	    int result;
       	    result = empId;
	    result = (empName != null ? empName.hashCode() : 0);
	    result = Float.floatToLongBits(empSalary);
	    result = (empProject != null ?
                   empProject.hashCode() : 0);
	    result = (empJoiningDate != null ?
                   empJoiningDate.hashCode() : 0);
	return result;
	}

	//toString-method
	@Override
	public String toSrting(){
		return "Employee{" +
		"empId=" + empId +
		", empName=" + empName +
		", empSalary=" + empSalary +
		", empProject=" + empProject +
		", empJoiningDate=" + empJoiningDate +
		"}";

	}
}

Then the object can be created like this:

Employee emp = new Employee(100,
			"Vivek",
			60000.00,
			"BLB",
			"01-25-2020");
</pre>
</code>
<br />
<p class="highlightme">The example with Records:</p>
<p>
The Java language (as of a preview feature in Java 14) provides a concise syntax for declaring records, in which all the programmer needs to do is to declare the component names and types that make up the record, like this:
</p>

<pre>
<code>
public record Employee(int empId,
		String empName,
		float empSalary,
		String empProject,
		LocalDateTime empJoiningDate) {}
</pre>
</code>

<p>
The new Concept is a record class (usually just called a record). This is an immutable transparent carrier for a fixed set of values known as the record components. Each component gives rise to a final field that holds the provided value and an accessor method to retrieve the value. The field name and the accessor name match the name of the component.
</p>

<p>
java.lang.Record is the supertype for all record classes. It is abstract and declares equals(), hashCode(), and toString() to be abstract methods.
The java.lang.Record class cannot be directly extended, as you can see by trying to compile some code like the following:
</p>

<pre>
<code>
public final class Employee extends Record {
    private final int empId;
    private final String empName;
    private final float empSalary;
    private final String empProject;
    private final LocalDateTime empJoiningDate;

    // ... rest of class elided
}
</pre>
</code>

<pre>
<code>
The compiler will reject the attempt, as follows:

$ javac --enable-preview -source 14 Employee.java

Employee.java:3: error: records cannot directly extend Record
public final class Employee extends Record {
             ^
</pre>
</code>

<p class="highlightme">Conclusion</p>
<p>
Records are intended to be simple data carriers, a version of tuples that fits into Java‚Äôs established type system in a logical and consistent manner. This will help many applications make domain classes clearer and smaller. It will also help teams eliminate many hand-coded implementations of the underlying pattern and reduce or remove the need for libraries.
</p>

<p>
However, we must always remember that until a finalized version of Java is delivered that contains a specific language feature, you should not rely on it. When talking about possible future features, as I have in this article, it should always be understood that the feature is being discussed for exploration purposes only.
</P>

<center><img width="800" height="450" src="https://fossbytes.com/wp-content/uploads/2017/09/Why-is-Java-the-best-programming-Language.png" class="responsive""></center>

</article>
</div>
</main>
</body>
</html>
